# -*- coding: utf-8 -*-
"""ASB Attendance

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/142mENRyX6_qGdnbGY0c4GW-zWw5CkTZy
"""

# Install pyTelegramBotAPI if not already installed
!pip install pyTelegramBotAPI

import telebot
from telebot import types
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import datetime
import logging
import calendar # NEW import
# import gspread.utils # Import gspread.utils for colnum_to_letter - This line is no longer needed

# ---------------- CONFIG ----------------
BOT_TOKEN = "8327191494:AAEwMoVUNm1HzJoNoU-b1a08iExoahjkqQI"
SHEET_NAME = "Attendance"

SESSIONS = ["1", "2", "3", "4", "5", "6"]
SUBJECTS = ["Python Programming", "UI/UX", "FCA", "IES"]

logging.basicConfig(level=logging.INFO)

# ---------------- INIT ----------------
bot = telebot.TeleBot(BOT_TOKEN)
user_data = {}

# ---------------- GOOGLE SHEETS ----------------
scope = [
    "https://spreadsheets.google.com/feeds",
    "https://www.googleapis.com/auth/drive"
]
creds = ServiceAccountCredentials.from_json_keyfile_name(
    "credentials.json", scope
)
client = gspread.authorize(creds)
sheet = client.open(SHEET_NAME).sheet1

# Helper function to convert column number to letter
def colnum_to_letter(colnum):
    """Converts a column number (1-indexed) to a column letter (e.g., 1 -> 'A', 27 -> 'AA')."""
    letter = ''
    while colnum > 0:
        colnum, remainder = divmod(colnum - 1, 26)
        letter = chr(65 + remainder) + letter
    return letter

# ---------------- START ----------------
@bot.message_handler(commands=["start", "attendance"])
def start_attendance(message):
    chat_id = message.chat.id
    user_data[chat_id] = {} # Initialize or clear user data for new session

    today_date = datetime.date.today().isoformat()
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton(f"Use Today's Date ({today_date})", callback_data=f"DEFAULT_DATE_{today_date}"))
    markup.add(types.InlineKeyboardButton("Select a different date", callback_data="SELECT_DATE_CALENDAR"))
    bot.send_message(chat_id, "Please choose an attendance date option:", reply_markup=markup)

# NEW callback handler for initial date choice
@bot.callback_query_handler(func=lambda call: call.data.startswith('DEFAULT_DATE_') or call.data == 'SELECT_DATE_CALENDAR')
def initial_date_choice_handler(call):
    chat_id = call.message.chat.id
    message_id = call.message.message_id
    data = call.data

    bot.answer_callback_query(call.id) # Acknowledge the callback

    if chat_id not in user_data: # Ensure user data is initialized
        user_data[chat_id] = {}
        bot.send_message(chat_id, "Session re-initialized. Please start over with /start or /attendance.", reply_markup=types.ReplyKeyboardRemove())
        return

    if data.startswith('DEFAULT_DATE_'):
        selected_date_str = data.split('_')[2]
        user_data[chat_id]["date"] = selected_date_str
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=f"üìÖ Attendance Date: {selected_date_str}")
        # Now ask user to record new or update existing session
        ask_session_action(chat_id)
    elif data == 'SELECT_DATE_CALENDAR':
        # Delete the previous message and show the calendar
        bot.delete_message(chat_id, message_id) # Optionally delete the previous message
        show_date_selector(chat_id) # Show the calendar


# NEW function to display calendar
def show_date_selector(chat_id, year=None, month=None, message_id=None):
    now = datetime.date.today()
    if year is None: year = now.year
    if month is None: month = now.month

    cal = calendar.Calendar(0) # Monday is the first day of the week
    month_days = cal.monthdayscalendar(year, month)

    markup = types.InlineKeyboardMarkup()
    # Month and Year header
    markup.add(types.InlineKeyboardButton(f"{calendar.month_name[month]} {year}", callback_data="ignore"))

    # Weekday headers
    week_header_row = []
    for day_name in ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"]:
        week_header_row.append(types.InlineKeyboardButton(day_name, callback_data="ignore"))
    markup.add(*week_header_row)

    # Days
    for week in month_days:
        row = []
        for day in week:
            if day == 0: # Empty day slot
                row.append(types.InlineKeyboardButton(" ", callback_data="ignore"))
            else:
                date_obj = datetime.date(year, month, day)
                date_str = date_obj.isoformat()
                button_text = f"_{day}_" if date_obj == now else str(day) # Highlight today
                row.append(types.InlineKeyboardButton(button_text, callback_data=f"CALENDAR_DATE_{date_str}"))
        markup.add(*row)

    # Navigation for months
    current_month_first_day = datetime.date(year, month, 1)
    prev_month_date = current_month_first_day - datetime.timedelta(days=1)

    if month == 12:
        next_month_year = year + 1
        next_month_month = 1
    else:
        next_month_year = year
        next_month_month = month + 1

    nav_row = [
        types.InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"CALENDAR_NAV_{prev_month_date.year}-{prev_month_date.month}"),
        types.InlineKeyboardButton("Today", callback_data=f"CALENDAR_TODAY_{now.year}-{now.month}-{now.day}"),
        types.InlineKeyboardButton("‚û°Ô∏è", callback_data=f"CALENDAR_NAV_{next_month_year}-{next_month_month}")
    ]
    markup.add(*nav_row)

    if message_id:
        bot.edit_message_reply_markup(chat_id, message_id, reply_markup=markup)
    else:
        bot.send_message(chat_id, "üìÖ Select an Attendance Date:", reply_markup=markup)

# NEW callback query handler
@bot.callback_query_handler(func=lambda call: call.data.startswith('CALENDAR_'))
def calendar_callback_handler(call):
    chat_id = call.message.chat.id
    message_id = call.message.message_id
    data_parts = call.data.split('_')
    action = data_parts[1]

    bot.answer_callback_query(call.id) # Acknowledge the callback

    # Check if user_data is initialized for this chat_id
    if chat_id not in user_data:
        user_data[chat_id] = {} # Initialize it if not present
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Session expired or re-initialized. Please start over with /start or /attendance.", reply_markup=types.ReplyKeyboardRemove())
        return

    if action == "NAV":
        year, month = map(int, data_parts[2].split('-'))
        show_date_selector(chat_id, year, month, message_id)
    elif action == "DATE":
        selected_date_str = data_parts[2]
        user_data[chat_id]["date"] = selected_date_str
        # Remove the calendar and send confirmation
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=f"üìÖ Attendance Date: {selected_date_str}")

        # Now ask user to record new or update existing session
        ask_session_action(chat_id)
    elif action == "TODAY":
        today_date = datetime.date.today()
        today_date_str = today_date.isoformat()
        user_data[chat_id]["date"] = today_date_str
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text=f"üìÖ Attendance Date: {today_date_str}")

        # Now ask user to record new or update existing session
        ask_session_action(chat_id)

# NEW function to ask the user what to do after date selection
def ask_session_action(chat_id):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add("Record New Session", "Update Existing Session", "Back", "Cancel") # Added Back button here
    msg = bot.send_message(chat_id, "What would you like to do for this date?", reply_markup=markup)
    bot.register_next_step_handler(msg, handle_session_action_choice)

# NEW handler for the choice after date selection
def handle_session_action_choice(message):
    chat_id = message.chat.id

    # Check for commands first
    if check_for_commands(message, 'handle_session_action_choice'):
        return

    choice = message.text.lower()

    if choice == "record new session":
        _display_session_selection_for_new(chat_id)
    elif choice == "update existing session":
        _display_session_selection_for_update(chat_id)
    else:
        bot.send_message(chat_id, "Invalid choice. Please select 'Record New Session' or 'Update Existing Session'.", reply_markup=types.ReplyKeyboardRemove())
        ask_session_action(chat_id) # Re-ask

# ---------------- DATE ----------------
# The `process_date` function is no longer needed as date selection is handled by the calendar.
# Its content has been moved or replaced by the calendar flow.
# def process_date(message):
#    chat_id = message.chat.id
#    if message.text.lower() != "yes":
#        user_data[chat_id]["date"] = message.text.strip()
#
#    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
#    markup.add(*SESSIONS)
#
#    msg = bot.send_message(chat_id, "üïí Select Session:", reply_markup=markup)
#    bot.register_next_step_handler(msg, process_session)

# NEW helper function to display session selection for new record
def _display_session_selection_for_new(chat_id):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add(*SESSIONS)
    markup.add("Back", "Cancel")
    msg = bot.send_message(chat_id, "üïí Select Session:", reply_markup=markup)
    user_data[chat_id]['action_type'] = 'record_new'
    bot.register_next_step_handler(msg, process_session)

# NEW helper function to display session selection for update
def _display_session_selection_for_update(chat_id):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add(*SESSIONS)
    markup.add("Back", "Cancel")
    msg = bot.send_message(chat_id, "üïí Select session to update:", reply_markup=markup)
    user_data[chat_id]['action_type'] = 'update_existing'
    bot.register_next_step_handler(msg, process_update_session_selection)

# NEW helper function to display subject selection
def _display_subject_selection(chat_id):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add(*SUBJECTS)
    markup.add("Back", "Cancel")
    msg = bot.send_message(chat_id, "üìö Select Subject:", reply_markup=markup)
    bot.register_next_step_handler(msg, process_subject)


# ---------------- SESSION ----------------
def process_session(message):
    chat_id = message.chat.id

    # Check for commands first
    if check_for_commands(message, 'process_session'):
        return

    selected_session = message.text
    user_data[chat_id]["session"] = selected_session

    # Check if a record for this date and session already exists
    # This check is only relevant if the user selected "Record New Session"
    if user_data.get(chat_id, {}).get('action_type') == 'record_new':
        current_date = user_data[chat_id]["date"]

        # Fetch all values to check for duplicates
        all_records = sheet.get_all_values()
        session_already_exists = False
        for i, record in enumerate(all_records):
            if i == 0: continue # Skip header row
            if record[0] == current_date and record[1] == selected_session:
                session_already_exists = True
                break

        if session_already_exists:
            markup = types.InlineKeyboardMarkup()
            markup.add(
                types.InlineKeyboardButton("Continue and Overwrite", callback_data="CONFIRM_OVERWRITE"),
                types.InlineKeyboardButton("Cancel New Entry", callback_data="CANCEL_NEW_ENTRY")
            )
            bot.send_message(
                chat_id,
                f"‚ö†Ô∏è Attendance for Session {selected_session} on {current_date} already exists. "
                "Choosing 'Continue and Overwrite' will update the subject and absentees for this session. "
                "What would you like to do?",
                reply_markup=markup
            )
            # Do not register next step handler yet, wait for inline keyboard callback
            return # Exit process_session, wait for user's decision

    # If no existing session found, or if this function is called after 'Update Existing Session' flow,
    # or if user chose to overwrite, proceed normally to ask for subject.
    _display_subject_selection(chat_id)

# NEW callback handler for overwrite confirmation
@bot.callback_query_handler(func=lambda call: call.data == 'CONFIRM_OVERWRITE' or call.data == 'CANCEL_NEW_ENTRY')
def handle_overwrite_confirmation(call):
    chat_id = call.message.chat.id
    message_id = call.message.message_id
    action = call.data

    bot.answer_callback_query(call.id) # Acknowledge the callback

    if action == "CONFIRM_OVERWRITE":
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="Proceeding to record/update attendance.") # Remove inline keyboard
        # Now, proceed to ask for subject
        _display_subject_selection(chat_id)
    elif action == "CANCEL_NEW_ENTRY":
        bot.edit_message_text(chat_id=chat_id, message_id=message_id, text="New entry cancelled.") # Remove inline keyboard
        handle_cancel_flow(chat_id)

# ---------------- SUBJECT ----------------
def process_subject(message):
    chat_id = message.chat.id

    # Check for commands first
    if check_for_commands(message, 'process_subject'):
        return

    user_data[chat_id]["subject"] = message.text

    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add("Back", "Cancel") # Add Back and Cancel for absentees step
    msg = bot.send_message(
        chat_id,
        "‚úçÔ∏è Enter ABSENTEES (comma separated)\nExample:\nAfreen, Amina",
        reply_markup=markup
    )
    bot.register_next_step_handler(msg, process_absentees)

# ---------------- ATTENDANCE ----------------
def process_absentees(message):
    chat_id = message.chat.id

    # Check for commands first
    if check_for_commands(message, 'process_absentees'):
        return

    absentees = [x.strip().lower() for x in message.text.split(",") if x.strip()]

    header = sheet.row_values(1)
    students = header[3:]  # from column D

    new_row_data = [
        user_data[chat_id]["date"],
        user_data[chat_id]["session"],
        user_data[chat_id]["subject"]
    ]

    for student in students:
        new_row_data.append("A" if student.lower() in absentees else "P")

    # Check for existing entry based on (date, session) and update or append
    all_records = sheet.get_all_values()
    found_row_index = -1 # 0-indexed, so +1 for gspread row number
    for i, record in enumerate(all_records):
        if i == 0: continue # Skip header row

        # Check if Date AND Session match
        if (record[0] == user_data[chat_id]["date"] and
            record[1] == user_data[chat_id]["session"]):
            found_row_index = i + 1 # gspread is 1-indexed
            break

    if found_row_index != -1:
        # Update existing row at found_row_index. The new_row_data contains the new subject.
        num_cols = len(header)
        end_col_letter = colnum_to_letter(num_cols)
        update_range = f"A{found_row_index}:{end_col_letter}{found_row_index}"
        sheet.update(update_range, [new_row_data])
        bot.send_message(chat_id, "‚úÖ Attendance updated successfully! (Note: Subject and absentees for this session on this date have been updated.)")
    else:
        # Append new row
        sheet.append_row(new_row_data)
        bot.send_message(chat_id, "‚úÖ Attendance saved successfully!")

    # Ask user what they want to do next
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    markup.add("Record New Session", "Update Existing Session", "Finish")
    msg = bot.send_message(
        chat_id,
        f"What would you like to do next for {user_data[chat_id]['date']}?",
        reply_markup=markup
    )
    bot.register_next_step_handler(msg, handle_continue_attendance_choice)

# ---------------- CONTINUE ATTENDANCE HANDLER ----------------
def handle_continue_attendance_choice(message):
    chat_id = message.chat.id

    # Check for commands first (only Cancel is relevant here, Back would be 'Finish' logic)
    if check_for_commands(message, 'handle_continue_attendance_choice'):
        return

    choice = message.text.lower()

    if choice == "record new session":
        _display_session_selection_for_new(chat_id)
    elif choice == "update existing session":
        _display_session_selection_for_update(chat_id)
    else: # "Finish" or any other response
        bot.send_message(
            chat_id,
            "üéâ All attendance recorded for today. You can type /start or /attendance to begin a new entry.",
            reply_markup=types.ReplyKeyboardRemove()
        )
        if chat_id in user_data:
            del user_data[chat_id]

# ---------------- PROCESS UPDATE SESSION SELECTION ----------------
def process_update_session_selection(message):
    chat_id = message.chat.id

    # Check for commands first
    if check_for_commands(message, 'process_update_session_selection'):
        return

    session_to_update = message.text
    user_data[chat_id]["session"] = session_to_update # Store the session to update

    _display_subject_selection(chat_id)

# ---------------- HELPER FUNCTIONS FOR COMMANDS ----------------
def handle_cancel_flow(chat_id):
    if chat_id in user_data:
        del user_data[chat_id] # Clear user data
    bot.send_message(chat_id, "‚ùå Attendance process cancelled.", reply_markup=types.ReplyKeyboardRemove())
    bot.send_message(chat_id, "You can type /start or /attendance to begin a new entry.", reply_markup=types.ReplyKeyboardRemove())


def check_for_commands(message, current_handler_name):
    chat_id = message.chat.id
    text = message.text

    if text == 'Cancel':
        handle_cancel_flow(chat_id)
        return True
    elif text == 'Back':
        bot.send_message(chat_id, "‚Ü©Ô∏è Going back...", reply_markup=types.ReplyKeyboardRemove())
        if current_handler_name == 'handle_session_action_choice':
            if 'date' in user_data.get(chat_id, {}): # Clear current date selection
                del user_data[chat_id]['date']
            # Restart from date selection
            start_attendance(message)
        elif current_handler_name in ['process_session', 'process_update_session_selection']:
            if 'session' in user_data.get(chat_id, {}):
                del user_data[chat_id]['session']
            if 'action_type' in user_data.get(chat_id, {}):
                del user_data[chat_id]['action_type']
            # Go back to choosing 'Record New Session' or 'Update Existing Session'
            ask_session_action(chat_id)
        elif current_handler_name == 'process_subject':
            if 'subject' in user_data.get(chat_id, {}):
                del user_data[chat_id]['subject']
            # Go back to session selection, distinguishing between new/update flow
            action_type = user_data.get(chat_id, {}).get('action_type')
            if action_type == 'record_new':
                _display_session_selection_for_new(chat_id)
            elif action_type == 'update_existing':
                _display_session_selection_for_update(chat_id)
            else: # Fallback if action_type is missing
                ask_session_action(chat_id)
        elif current_handler_name == 'process_absentees':
            if 'subject' in user_data.get(chat_id, {}):
                del user_data[chat_id]['subject']
            # Go back to subject selection
            _display_subject_selection(chat_id)
        elif current_handler_name == 'handle_continue_attendance_choice':
            # This acts like cancelling the current date's entry flow
            if 'session' in user_data.get(chat_id, {}):
                del user_data[chat_id]['session']
            if 'subject' in user_data.get(chat_id, {}):
                del user_data[chat_id]['subject']
            if 'action_type' in user_data.get(chat_id, {}):
                del user_data[chat_id]['action_type']
            ask_session_action(chat_id)
        return True
    return False

# ---------------- RUN ----------------
bot.infinity_polling()

